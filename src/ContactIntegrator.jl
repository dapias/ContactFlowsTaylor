module ContactIntegrator

export contacthointegration!

using TaylorSeries

const Taylororder = 28
const tolerance = 1.0e-20

"""
Function that takes an array corresponding to the initial conditions,
solve the equations of motion and returns a Taylor series array
and the time step for which the series still converges.
"""
function taylorStepper{T<:Real}(field::Function, vec0::Array{T,1}, c::Float64, beta::Float64)

  vec1T = field( vec0, c, beta)

  # Step-size
  hh = Inf
  for i in eachindex(vec0)
    @inbounds h1 = stepsize( vec1T[i])
    hh = min( hh, h1 )
  end

  return hh, vec1T
end


"""
Returns the maximum step size taken into account the tolerance and the last two coefficients of the Taylor series
"""
function stepsize{T<:Real}(x::Taylor1{T})
  order = x.order
  h = Inf
  for k in [order-1, order]
    kinv = 1.0/k
    aux = abs( x.coeffs[k+1] )
    h = min(h, (tolerance/aux)^kinv)
  end
  return h
end

"""
Function that contains the contact equations of motion generated by the contact hamiltonian of the harmonic oscillator in
the canonical ensemble with inverse of temperature  Î². With *f(S)* the logistic distribution with mean *c*. The function takes an array, promotes it to an
Taylor series array, solve the equations of motion and returns the solution as a Taylor series
"""
function contacthofield{T<:Real}(vec0::Array{T,1},c::T, beta::T)
  order = Taylororder
  dim = length(vec0) #Dimension of the phase space

  vec0T = [ Taylor1([vec0[i]], order) for i in 1:dim]  #Promotion of the initial array to a Taylor series array

  y = [ Taylor1(0., order) for i=1:dim ]   #Auxiliar array
  D = [ Taylor1(0., order) for i=1:dim ]   #Auxiliar array

  for k = 0:order-1
    knext = k+1
    for i in 1:dim
      y[i] = Taylor1( vec0T[i].coeffs[1:k+1], k)  #Copy in the array "y" the coefficients of the Taylor series array vecO
    end

    #Equations of motion generated by h = (exp(-beta H)/Z f(S))^(-1/2) with H = 1/2p^2 + 2q^2, Z = pi/beta and f(S) = exp(S-c)/(1 + exp(S-c))^2
    #The order in the array D (and y) is D[1] = q, D[2] = p, D[3] = S

    Z = pi/beta
    H = y[2]^2/2. + 2.*y[1]^2
    f = exp(y[3] - c)/(1 + exp(y[3] - c))^2.
    h = (exp(-beta*H)*f/Z)^(-0.5)

    rho = h^(-2.)
    theta = -log(rho)


    D[1] = h/2.*beta*y[2]
    D[2] = h/2.*(-beta*4*q + p*(exp(S-c) -1)/(exp(S-c)+1))
    D[3] = h/2.*(y[2]^2.*beta + 2.)

    #Update of the coefficients
    for i in 1:dim
      vec0T[i].coeffs[knext+1]  = D[i].coeffs[knext] / knext
    end

  end
  return vec0T
end

""" # contacthointegration!(nsampling, initcond, deltatsample, c, beta)
Function that performs the numerical integration of the contact harmonic oscillator system in the canonical ensemble (using the logistic
distribution for *f(S)*). The initial condition is evolved through the simulation.
The function returns the arrays time, p, q and S. These arrays contain the numerical values of those variables sampled along the simulation.
"""
function contacthointegration!{T<:Real}(nsampling::Int64, initcond::Array{T,1}, deltatsample::T, c::T, beta::T)
  t::Float64 = 0.0
  x = initcond

  #Arrays where the data will be saved
  q = Array(Float64, nsampling)
  p = Array(Float64, nsampling)
  S = Array(Float64, nsampling)
  #time = Array(Float64, nsampling)

  #Saves the initial condition
  q[1] = x[1]
  p[1] = x[2]
  S[1] = x[3]

  #Time array for sampling
  time = [deltatsample*(i-1) for i in 1:nsampling]
  temporarytime = 0.


  for i in 2:nsampling
    j = true
    #This loop goes until we take the sample corresponding to time[i]
    while j
      #Find the step-size and Taylor series expanded around x
      t, vec1T::Array{Taylor1{Real},1} = taylorStepper(contacthofield, x, c, beta )
      #Evaluates the Taylor series
      for k in eachindex(x)
        @inbounds x[k] = evaluate( vec1T[k], t )
      end

      temporarytime += t

      #Condition to check if we have passed the sampling time
      if time[i] < temporarytime
        t_last = temporarytime -t
        for k in eachindex(x)
          @inbounds x[k] = evaluate( vec1T[k], time[i] - t_last)
        end
        temporarytime = time[i]
        q[i] = x[1]
        p[i] = x[2]
        S[i] = x[3]
        j = false
      end

    end
  end

  time, q, p, S


end

end

